---
title: "Workgroup 3: Data exploration with R (II)"
author: "Leticia Pablos Robles"
---

# üìäData visualization in R: introduction to ggplot

## Basic Plotting

``` r
plot(data$column1, data$column2)  # Scatter plot  
hist(data$column1)                # Histogram 
```

## 

``` r
plot(mtcars$wt, mtcars$mpg, main = "MPG vs Weight",      xlab = "Weight",      ylab = "Miles Per Gallon") 
```

### 

## Using *ggplot2* library

## 

# Descriptive statistics calculations

# Data summary write up

# üìù Exercises

## Assignment#2 : Data Exploration with R

For the exercises in this assignment we will use a dataset with some data from a real Self-Paced Reading study on Negative Polarity Items and complementizer agreement in Basque (see Pablos, L., & Saddy, D. (2009). Negative polarity items and complementizer agreement in Basque. in Alter, K., Horne, M., Lindgren, M., Roll, M., & von Koss Torkildsen, J.(Eds.), Papers from Brain Talk: Discourse with and in the Brain. The 1st Birgit Rausing Language Program Conference in Linguistics. Lund: Lund University, Media Tryck. ISBN: 978-91-633-5561-5.)

### 1. Loading the required dataset

The function *load()* allows to read a file where variables are saved.

You can store in a file data from any variable in an R format using the function *save()*. For more information on reading and writing data in R, I recommend reading the summary in the R Cookbook available [here](https://www.oreilly.com/library/view/r-cookbook/9780596809287/ch04.html).

```{r}
load("BasqueNPISampleData.Rda") 
head(BasqueNPI)
View(BasqueNPI)
```

After this step you have a dataframe called BasqueNPI available in the environment, with the following variables

-   EXPT - Specifies the type of data of the item collected, it contains three different values:

    -   practice: items presented at the beginning of the experiment to practice the method
    -   filler: items included in the experiment to ‚Äòdisguise‚Äô the real measured target sentences.
    -   basquenpi: target items corresponding to the experimental manipulation.

-   Item ‚Äì Factor identifying the sentence used (coded as a number from 1 to 72).

-   Subject ‚Äì Factor identifying the participant on the experiment (coded as a number from 1 to 32)

-   EmbeddedSubject ‚Äì Factor/predictor indicating the nature of the embedded subject with the following levels:

    -   \[Empty\] ‚Äì for practice and filler items
    -   NP ‚Äì for target sentences with a Noun Phrase as subject
    -   NPI ‚Äì for target sentences with a Negative Polarity Item as subject

-   Agreement Morphology ‚Äì Factor/predictor indicating the nature of agreement with the following levels:

    -   \[Empty\] ‚Äì for practice and filler items
    -   Declarative ‚Äì for target sentences that contained a complementizer with declarative morphology
    -   Partitive ‚Äì for target sentences that contained a complementizer with partitive morphology

-   SequenceBin ‚Äì the position of the item in the sequence seen by the subject.

-   WordNumber ‚Äì the word number in the sentence (starting with 1)

-   Word ‚Äì Actual word presented

-   RegionNumber ‚Äì Region number for the analysis of the reading time

-   RWRT ‚Äì RaW (recorded) Reading Time of the word

-   RWZS ‚Äì Z-Score of the raw reading time

-   RSRT ‚Äì Calculated Residual Reading Time

-   RSZS ‚Äì Z-Score of the residual reading time

-   QPCT ‚Äì Correctness of the comprehension response (100 ‚Äì correct; 0 ‚Äì incorrect)

**This data is a real set with the outputs generated by the software [*Linger*](https://tedlab.mit.edu/~dr/Linger/) created by the MIT Ted Lab to easily conduct Self Paced reading experiments**

Remember you can have an overview of the dataframe using the *str()* function:

```{r}
str(BasqueNPI)
```

### 2. Explore Data & Calculate Summary Statistics

#### 2.1 Select a subset of the data

Select a subset of data with only the target items from the experiment (EXPT== ‚Äúbasquenpi‚Äù) and put them in a variable called 'basquenpi_data'

There are several ways to select a part of a dataframe. Let's see three methods

a.  Using a condition to index, as shown in the key to Assignment #1:

```{r}
basquenpi_data<-BasqueNPI[BasqueNPI$EXPT=="basquenpi",] 
head(basquenpi_data)
```

In the example above, note that you need to use a comma after the condition in brackets (\[BasqueNPI\$EXPT=="basquenpi"**,**\]) to indicate that you want all columns to be returned. If you miss the comma, you will get an error like the following:

`Error in`\[.data.frame`(BasqueNPI, BasqueNPI$EXPT == "basquenpi") : undefined columns selected`

b.  Using the *subset()* function

The subset function is more intuitive and easy to read in the code. As you can see in the help page (*help(subset)*), the function takes three parameters: the first is the name of the data-frame. The second is a condition with the selection and the third can be used to specify the columns we are interested to keep. In this case, to simply make a selection we can do:

```{r}
basquenpi_data<-subset(BasqueNPI,EXPT=="basquenpi") 
head(basquenpi_data)
```

As you can see the result is the same as above.

c.  Using *pipes* as you explored in assignment #1 and the *filter()* function.

Remember to load the *tidyverse* library to use pipes.

```{r}
library(tidyverse) 
basquenpi_data<- BasqueNPI %>% filter(EXPT=="basquenpi") 
head(basquenpi_data)
```

Once again, the results is the same. Pipes are more readable and allow to concatenate operations. For example, if we want the data to be filtered but also sorted by *Item* for example, we could use the *arrange()* function:

```{r}
basquenpi_data<- BasqueNPI %>% filter(EXPT=="basquenpi") %>% arrange(Item) head(basquenpi_data)
```

::: callout-tip
#### Remove unused levels {#UnusedLevelsRemoval}

If we look at a summary of the new variable using *str()*, we can see that the factors `EXPT`,`EmbeddedSubject` and `AgreementMorphology` each still displays three levels, even though the data does not use them. See the usage of *summary()* to check it:
:::

```{r}
str(basquenpi_data)
```

```{r}
summary(basquenpi_data$EXPT)
```

```{r}
summary(basquenpi_data$EmbeddedSubject)
```

To eliminate unused levels in the new dataset we can use the function *droplevels()*. Take a look at the difference after applying it on the number of levels of factors `EXPT`,`EmbeddedSubject` and `AgreementMorphology`.

```{r}
basquenpi_data<-droplevels(basquenpi_data) 
str(basquenpi_data)
```

#### 2.2 Plot a histogram of the Raw Reading Time (RWRT) using hist(). Also plot a histogram of the Residual Reading Time (RSRT). What can you notice on the distributions?

Plotting a histogram of the data can be done easily with the *hist()* function, as indicated in the class handouts.

Let's first plot a histogram of the Raw Reading Time (RWRT)

```{r}
hist(basquenpi_data$RWRT)
```

What can we say about this distribution? A few notes:

-   It is a disribution skewed to the right with a lower limit of 0 -\> Since RWRT measures the Raw Reading Time, the minimum reading time is zero, obviously, as it can not contain negatives values.

-   Most values seem to be between 0 and 1000: the default plot created by *hist()* has only 10 subdivisions or *bins*. To have a more fine grouping, we can indicate the number of bins used with the parameter *breaks*

```{r}
hist(basquenpi_data$RWRT,breaks=40)
```

-   Now it can be clearly seen that the bigger proportion of reading times is between 500 and 1000 ms.

-   The distribution is very right skewed because there are probably a few measurements with very long reading time (e.g. possibly a participant loosing attention and not pressing a key).

We can check the histogram only for values of the RWRT less than a certain limit.

Knowing our experiment we can make an initial data filtering. For example, Looking at the plot above, we could eliminate those trials with RWRT \> 3000 ms considering that they are too long to be valid. Let's create a new variable called *basquenpi_data_filtered* with only those trials with RWRT \< 3000 and plot the resulting histogram.

```{r}
basquenpi_data_filtered<- basquenpi_data %>% filter(RWRT<3000) 
hist(basquenpi_data_filtered$RWRT,breaks=40)
```

-   Now we can see that the distribution is more symmetric, after removing outlayer points with RWRT \> 3000. If we want to see how many trials we have removed with the filtering, we can use the *nrow()* function that counts the number of entries in the original and in the filtered dataframes, or calculate the percentage of trial removed $Percentage\,removed\,trials = \dfrac{n_{total}-n_{filtered}}{n_{total}}*100$.

```{r}
nrow(basquenpi_data_filtered) 
nrow(basquenpi_data)  
#Percentage of trials removed  
(nrow(basquenpi_data)-nrow(basquenpi_data_filtered))/nrow(basquenpi_data) * 100 
```

As can be seen, only 0.6% of the trials are excluded with the filtering RWRT \< 3000

Finally, we plot a histogram for the Residual Reading Time. The Residual Reading Time (RSRT) is a way to correct for sentence length, word length, and individual differences between participants' reading speeds. It is referenced to the average reading time per participant, and can have negative values (indicating faster reading than the average). We will look at the way it is calculated in a later assignment once we have gone over the principles of regression.

For the purpose of this exercise we can plot the histogram to compare with the RWRT.

```{r}
hist(basquenpi_data$RSRT,breaks=40)
```

-   The distribution is roughly centered around 0, and it is more symmetric than the RWRT.

-   If we plot the distribution of RSRT on the dataset were we had filtered based on RWRT\<3000, we can see even more clearly that the distribution looks more like a **normal distribution**

```{r}
hist(basquenpi_data_filtered$RSRT,breaks=40)
```

#### Extra information: Skewness and kurtosis

The assignment did not ask for it, but I show below how you could calculate the skewness and kurtosis values using the functions with the same name in the library *moments* (in case you don't have it installed, use first *install.packages("moments")*)

First let's calculate the skewness for the RWRT.

```{r}
library(moments) 
skewness(basquenpi_data$RWRT)
```

-   A positive skewness value means that the distribution is right skewed. This is quite clear looking at the histogram above.

Let's look now at the value of the kurtosis

```{r}
kurtosis(basquenpi_data$RWRT)
```

-   A positive kurtosis indicates a distribution more *peaked* than a normal distribution with the same mean and standard deviation.

Below we calculate the same values for the RSRT

```{r}
skewness(basquenpi_data$RSRT) 
kurtosis(basquenpi_data$RSRT)
```

-   As can be seen the RSRT is even more skewed and with higher kurtosis than the RWRT distribution.

Finally let's look at the values on the dataset for values of RT \< 3000 ms

```{r}
skewness(basquenpi_data_filtered$RWRT) 
kurtosis(basquenpi_data_filtered$RWRT) 
skewness(basquenpi_data_filtered$RSRT) 
kurtosis(basquenpi_data_filtered$RSRT)
```

-   The distribution is now closer to a normal in both measures as expected.

#### 2.3 Calculate mean and standard deviation {#2b3}

Calculate the mean and standard deviation of the Raw Reading Time (RWRT) for the different experimental conditions in Region Number 5 and fill in the empty slots in the two tables below with the resulting information.

First, let's select the data in region 5

```{r}
basquenpi_data_r5<- basquenpi_data %>% filter(RegionNumber==5) 
head(basquenpi_data_r5)
```

To calculate the mean we use the *mean()* function. For each of the conditions, we can create a variable, selecting the case to fill the table. In the example below, I use both pipes and the *subset()* function to illustrate both possible ways of applying a filter.

```{r}
c1<- basquenpi_data_r5 %>% filter(EmbeddedSubject=="NPI" & AgreementMorphology=="Partitive") 
head(c1)  
c2<- basquenpi_data_r5 %>% filter(EmbeddedSubject=="NP" & AgreementMorphology=="Partitive") 
head(c2)  
c3<-subset(basquenpi_data_r5,EmbeddedSubject=="NPI" & AgreementMorphology=="Declarative") 
head(c3)  
c4<-subset(basquenpi_data_r5,EmbeddedSubject=="NP" & AgreementMorphology=="Declarative") 
head(c4)
```

Now for each of the conditions we can calculate the mean

```{r}
mean(c1$RWRT) 
mean(c2$RWRT) 
mean(c3$RWRT) 
mean(c4$RWRT)
```

The same can be done for the standard deviation using the *sd()* function

```{r}
sd(c1$RWRT) 
sd(c2$RWRT) 
sd(c3$RWRT) 
sd(c4$RWRT)
```

|          ***Mean*** |             | EmbeddedSubject |        |
|--------------------:|------------:|:---------------:|:------:|
|                     |             |       NP        |  NPI   |
| AgreementMorphology | Declarative |     750.70      | 661.67 |
|                     |   Partitive |     751.33      | 586.60 |

|       ***Std Dev*** |             | EmbeddedSubject |        |
|--------------------:|------------:|:---------------:|:------:|
|                     |             |       NP        |  NPI   |
| AgreementMorphology | Declarative |     357.30      | 807.98 |
|                     |   Partitive |     440.71      | 274.91 |

> ***Advanced***: An easier way to calculate the mean and std deviation for the different conditions, is to use the *aggregate()* function. *aggregate()*, as the name indicates, groups the data by a list of variables (created with the *list()* function), applying an operation. So, to generate the table for the means we can use:

```{r}
aggregate(basquenpi_data_r5$RWRT,list(EmbeddedSubject = basquenpi_data_r5$EmbeddedSubject,                                       AgreementMorphology=basquenpi_data_r5$AgreementMorphology),mean)
```

> and for the standard deviation, we can use

```{r}
aggregate(basquenpi_data_r5$RWRT,list(EmbeddedSubject = basquenpi_data_r5$EmbeddedSubject,                                       AgreementMorphology=basquenpi_data_r5$AgreementMorphology),sd)
```

You will see one more way to generate these summaries in [section 3](#dplyr)

#### 2.4 Calculate five-points summary

Calculate and create a table with the five-point summary (i.e., min, max, median, 1st quartile(Q1) and 3rd quartile(Q3)) for the Residual Reading Time (RSRT) for the following subset of data:

-   EmbeddedSubject = NP
-   AgreementMorphology = Partitive
-   Region Number = 5

In [section 2.3](#2b3) we created variables for the data in region 5 for each of the conditions. In particular, the call below created a variable `c2` with the data we are interested in.

`c2<- basquenpi_data_r5 %>% filter(EmbeddedSubject=="NP" & AgreementMorphology=="Partitive")`

As described in the lecture notes, we can use *summary()* to extract the five-point-summary for the variable of interest. In this case, for the RSRT, we can simply run the following:

```{r}
summary(c2$RSRT)
```

As you can see from the values, the Median is a better representation of the center of the distribution that the Mean, that is affected by outliers. Looking at the 3rd quantile, 75% of the data points are below 120.08 ms.

### 2.5 Produce a boxplot

Produce a boxplot for the RWRT in different conditions reflected in the table of [task 2.3](#2b3)

Considering the example presented during the lecture.

`boxplot(verbs$LengthOfTheme ~ verbs$AnimacyOfTheme,col="lightblue", horizontal=TRUE)`

where you can read `verbs$LengthOfTheme ~ verbs$AnimacyOfTheme` as: *LengthOfTheme **as a function of** AnimacyOfTheme*.

To include more than one independent variable in boxplot, use the + sign. So for example `A~B+C`, could be read as *A **as a function of** B **combined with** C*.

For our case, the conditions are a combination of *EmbeddedSubject* and *AgreementMorphology*, so we can write:

```{r}
boxplot(basquenpi_data_r5$RWRT ~ basquenpi_data_r5$EmbeddedSubject+                                  basquenpi_data_r5$AgreementMorphology,col="lightblue")
```

As you can see, the plot contains columns for the combinations of the factor `EmbeddedSubject` and `AgreementMorphology` \[\^1\].

**Important:** Your data will also contain columns for the combinations with the *\[Empty\]* level, that have no data. To remove those, see the [Tip above](#UnusedLevelsRemoval)

A few observation on the plot:

-   There is a clear outlier in the *NPI-Declarative* condition.
-   The *NP-Partitive* condition seems to have more dispersion that the other ones.

As done in [task 2.2](#2b2) we could look at the subset of data from region 5 where the raw reading time (RWRT) is \< 3000 ms for example, and produce again a boxplot. I include below the plot for the complete data, and the filtered

```{r}
basquenpi_data_r5_filtered<-subset(basquenpi_data_r5,RWRT<3000) boxplot(basquenpi_data_r5_filtered$RWRT ~ basquenpi_data_r5_filtered$EmbeddedSubject +                                            basquenpi_data_r5_filtered$AgreementMorphology,col="lightblue")
```

Now it is clearer to appretiate what is the difference between the different conditions.

##### 2.5.1. Create a boxplot for RSRT

What can you observe in the data? Are many outliers present?

Just as done above, we can create boxplot. I include both the plots for the full set of data, and the data filtered to using RWRT \< 3000 ms

```{r}
boxplot(basquenpi_data_r5$RSRT ~ basquenpi_data_r5$EmbeddedSubject +                                   basquenpi_data_r5$AgreementMorphology,col="lightblue")  boxplot(basquenpi_data_r5_filtered$RSRT ~ basquenpi_data_r5_filtered$EmbeddedSubject +                                            basquenpi_data_r5_filtered$AgreementMorphology,col="lightblue")
```

##### 2.5.2. Comment on the differences between the RWRT and RSRT plot.

A few notes on both plots:

-   In the RWRT plots it can be seen that NPI conditions hae lower dispersion than NP conditions (boxes are smaller)
-   the RSRT is centered around 0 ms, as expected, however there are still a very significant number of outliers, with residuals over 1000 ms. This requires assessment during data analysis. We will look at this in future assignments.

#### 2.6. Normality checks

To check the distribution of the data, we saw in the lecture that a Quantile-Quantile Plot (qqplot) can be used. The function qqplot() is generic and compares some data with any type of distribution. To compare your data with a normal distribution and check normality, you can use qnorm().

We generate the Quartile-Quartile plot for RWRT using the command below

```{r}
qqnorm(basquenpi_data$RWRT)
```

The plot deviates clearly from a straight line, as expected by the skewness and kurtosis values calculated in [task 2.2](#2.2).

For comparison, let's look at the q-q plot for the filtered data

```{r}
qqnorm(basquenpi_data_filtered$RWRT)
```

Although the plot is more linear, still deviates from the required normal distribution to apply general statistics methods. When data is not normally distribute it, we have to perform:

-   Additional filtering to eliminate outliers
-   possibly a *data transformation* to perform the analysis
-   Use non-parametric methods for data analysis.

We will look at this later in the course.

### Task#3: Calculate Data Summaries with `dplyr` {#dplyr}

Now we will create data summaries using the `dplyr` library. The `dplyr` package in R is a great addition to inspect and work with dataframes and it is loaded as part of the *tidyverse* library.

`{r} library(tidyverse)}`

### 3.1. Read the primers on the use of `dplyr`

### 3.2. Use `dplyr`: {#3b2}

Use the *filter()*, *group_by()* and *summarize()* functions in `dplyr` to generate a dataframe called `basquenpi_data_summary` with the data grouped by the factors `RegionNumber`, `EmbeddedSubject` and `AgreementMorphology`, and summarized by adding columns with the mean and standard deviations of the Raw Reading Time and Residual Reading Time.

We can quickly group our data and extract summaries using this functions as follows

```{r}
basquenpi_data_summary<-group_by(basquenpi_data,EmbeddedSubject,AgreementMorphology,RegionNumber) basquenpi_data_summary<-summarize(basquenpi_data_summary,mean_rt=mean(RWRT),                                   mean_rs=mean(RSRT),sd_rt=sd(RWRT),sd_rs=sd(RSRT)) head(basquenpi_data_summary)
```

Note that the same can be done using pipes:

\small

```{r}
basquenpi_data_summary<-basquenpi_data %>% group_by(EmbeddedSubject,AgreementMorphology,RegionNumber) %>%                               summarize(mean_rt=mean(RWRT),mean_rs=mean(RSRT),sd_rt=sd(RWRT),sd_rs=sd(RSRT))  
head(basquenpi_data_summary,10)
```

\normalsize

This dataframe now contains a column with the mean and standard deviation for both the RSRT and RWRT for every region. For example, to get the same information as in [task 2.3](#2b3) we can use the *filter()* function to select part of the dataframe

```{r}
basquenpi_data_summary_r5<- basquenpi_data_summary %>% filter(RegionNumber==5) 
head(basquenpi_data_summary_r5)
```

Which are the same values found before.

**Tip**: Practice and become familiar with the dplyr function to easily access and manipulate your data.

### Task#4: Plotting with ggplot2

### 4.1 The ggplot2 library

To plot the data, we will start using the library `ggplot2`. This library is a very powerful tool to provide advanced graphs based on the concept of a grammar of graphics. It is also loaded when using the *tidyverse* library. to load it separately you can also use:

```{r}
library(ggplot2)
```

The concept behind ggplot2 divides a plot into three different fundamental parts: Plot = Data + Aesthetics + Geometry. The principal components of every plot can be defined as follows: \* Data is a data frame with the source of the data to be represented. \* Aesthetics is used to indicate x and y variables. It can also be used to control the color/ size / shape of points, the height of bars, etc. \* Geometry defines the type of graphics (i.e., histogram, box plot, line plot, density plot, dot plot, etc.).

There are two major functions in a ggplot2 package: qplot() and ggplot() functions. \* qplot() stands for a quick plot, which can be used to produce simple plots easily. \* ggplot() function is more flexible and robust than qplot, and it is intended for building a plot piece by piece.

### 4.2. Basic line plot with ggplot2

The plot we want to create shows the mean RWRT for each region for the conditions where EmbeddedSubject==NP, for the two different levels of AgreementMorphology.

From the dataframe created in [task 3.2](#3b2) first we select the subset of cases where *EmbeddedSubject==NP*

```{r}
basque_npi_summary_NP<-basquenpi_data_summary %>% filter(EmbeddedSubject=="NP")
```

First step is to create a *definition* for a plot. With the command below, we create a plot based on the data in `basque_npi_summary_NP` and *save* the plot definition in a variable called p. Typing the name of the variable shows the information from the plot as we build it.

```{r}
p<-ggplot(basque_npi_summary_NP) 
p
```

At this point, nothing is shown, because we only specified that we will make a plot based on the data. The next step is to add the *Aesthetics*. This specifies what the data will be:

```{r}
p<-p+aes(x=RegionNumber, y=mean_rt) 
p
```

With the command above, we informed that we will plot the *mean_rt* as a function of the *RegionNumber*. Still nothing is displayed, because we haven't said yet how we plot it (lines, points, bars, etc). As you can see, we don't need to provide in the commad the name of the variable containing the columns *mean_rt* and *RegionNumber*, because `p` *knows* which is the underlying data of the graph.

With the next command, we specify that we want to have a line using *geom_line()*, where each type of line corresponds one of the levels of `AgreementMorphology`

```{r}
p+geom_line(aes(linetype=AgreementMorphology))
```

Now, as you can see we get a graph!

On purpose, I did not saved the result back in the *p* variable, to illustrate a point. What if we wanted to have instead a barchart? We just call *geom_bar()* instead.

```{r}
p+geom_bar(stat="identity",aes(fill=AgreementMorphology),position=position_dodge() )
```

Coming back to our example, let's add data points to the chart using *geom_point()*, where each point shape is also dependent on the level of `Agreement Morphology`.

```{r}
p<-p+geom_line(aes(linetype=AgreementMorphology))+geom_point(aes(shape=AgreementMorphology)) 
p
```

We have now all the information we wanted in the chart and stored in the variable *p*. For the axis, the `RegionNumber` only makes sense as a discrete value. The command below adds information on the x scale, defining it a continuous with values in a sequence from 1 to 10 in steps of 1.

```{r}
p<-p+scale_x_continuous(breaks = seq(1,10,1)) 
p
```

The last step is to complete the *decorations* of the graph. We can do that using a number of functions from the `ggplot2` library.

```{r}
p+scale_color_grey()+theme_classic()
p
```

> **Note on ggplot2:** The intention of this example was to show the power of `ggplot2` to produce graphs of all types. It is beyond the scope of this course to learn how to use it and you are **not** expected to know it for the exams. For the interested readers there are several books and resources on the topic:

-   [*R Graphics Cookbook*](http://shop.oreilly.com/product/0636920023135.do) by Winston Chang
-   [*ggplot2: Elegant Graphics for Data Analysis*](https://www.springer.com/gp/book/9780387981413) by Hadley Wickham
